#!/bin/python3
import os
import sys
import argparse
import logging
import shutil

def parse_file(path: str, hostname: str, base: str) -> bytes:
    dest_hostnames = None
    output_buffer = []
    parsing_for = None
    mode = None
    lc = 0
    with open(path, "r") as fp:
        while True:
            line = fp.readline()
            lc+=1
            if not line:
                break
            if line.startswith("##$"):
                # "##$ hosts: host1, host2" -> directive = "hosts", data = "host1, host2"
                directive = ""
                data = None
                v = line[line.find("##$")+3:].strip().split(":", 1)
                directive = v[0]
                if len(v) == 2:
                    data = v[1]
                match directive.strip():
                    case "hosts":
                        if not dest_hostnames:
                            dest_hostnames = set(map(lambda x: x.strip(), data.split(",")))
                            logging.debug(f"{base} is for {dest_hostnames}")
                            if not hostname in dest_hostnames:
                                logging.info(f"{base} not for me, skipping")
                                return None
                        else: #hostnames already found
                            logging.error(f"{base}:L{lc} unexpected hosts directive - hosts already declared")
                            return None
                    case "only":
                        if parsing_for:
                            logging.error(f"{base}:L{lc} unexpected only directive - already in block")
                            return None
                        elif dest_hostnames:
                            hostnames = set(map(lambda x: x.strip(), data.split(",")))
                            parsing_for = hostnames
                            mode = "only"
                        else:
                            logging.error(f"{base}:L{lc} unexpected only directive - hosts not defined yet")
                            return None
                    case "not":
                        if parsing_for:
                            logging.error(f"{base}:L{lc} unexpected not directive - already in block")
                            return None
                        elif dest_hostnames:
                            hostnames = set(map(lambda x: x.strip(), data.split(",")))
                            parsing_for = hostnames
                            mode = "not"
                        else:
                            logging.error(f"{base}:L{lc} unexpected not directive - hosts not defined yet")
                            return None
                    case "end":
                        if parsing_for:
                            parsing_for = None
                            mode = None
                        else:
                            logging.error(f"{base}:L{lc} unexpected end directive")
                            return None
                    case _:
                        logging.warning(f"{base}:L{lc} unknown dmg directive {directive}")    
            elif mode == None or (mode == "not" and hostname not in parsing_for) or (mode == "only" and hostname in parsing_for):
                output_buffer.append(line)
            

    return "".join(output_buffer).encode("utf-8")
            

if __name__ == "__main__":

    if sys.version_info.minor < 10:
        print("python 3.10 or greater is required to use this software")
        os._exit(1)

    agp = argparse.ArgumentParser(description="dotfile manager")
    #flags
    agp.add_argument("-l", dest="loglevel", help="Set the log level.", type=str, default="info", choices=["info", "warning", "error", "debug"])
    agp.add_argument("--dry", dest="dryrun", help="Dry run: operate normally, but do not write anything to disk.", action=argparse.BooleanOptionalAction)
    #actions
    agp.add_argument("-a", dest="action", help="Action to take.", choices=["deploy", "import"], required=True)
    agp.add_argument("-f", dest="file", help="Generic file argument. Used for import and deploy.")
    agp.add_argument("-s", dest="dir", help="Source directory. May use DMG_ROOT env variable instead.", type=str, default=os.path.expandvars(os.getenv("DMG_ROOT")))
    args = agp.parse_args()
    logging.basicConfig(level=args.loglevel.upper())

    DMG_DIR = args.dir
    if not DMG_DIR:
        logging.error("DMG_ROOT not set and -s option not passed, exiting")
        os._exit(1)

    logging.debug(f"DMG_ROOT is set to {DMG_DIR}")
    objects = os.listdir(DMG_DIR)
    HOSTNAME = os.uname()[1]
    match args.action:
        case "deploy":
            if not args.file: #all files
                for root, dirs, files in os.walk(DMG_DIR):
                    for fname in files:
                        fpath = os.path.join(root, fname)
                        dest = fpath[len(DMG_DIR):]
                        fcontent = parse_file(fpath, HOSTNAME, dest)
                        logging.debug(fpath+" -> "+dest)
                        if not fcontent:
                            #parser failed
                            logging.error(f"{fpath}: parsing failed")
                        elif not args.dryrun:
                            logging.info(f"deploying {dest}")
                            os.makedirs(os.path.dirname(dest), exist_ok=True)
                            f = open(dest, 'wb')
                            f.write(fcontent)
                            f.close()
                        else:
                            logging.info(f"{fpath}: parsing ok")
            else: #one files
                pass
        case "import":
            if not args.file:
                logging.error("file argument required for import")
                os._exit(1)
            else:
                if not args.dryrun:
                    if os.path.exists(args.file):
                        dest = DMG_DIR + "/" + os.path.abspath(args.file)
                        os.makedirs(os.path.dirname(dest), exist_ok=True)
                        shutil.copy(args.file, dest)
                        logging.info(f"imported {args.file} -> {dest}")
                    else:
                        logging.error(f"import failed: file {args.file} does not exist")
                        os._exit(1)